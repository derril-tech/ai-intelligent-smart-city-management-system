# THE PROJECT BRIEF #

# Project Name #
INTELLIGENT SMART CITY MANAGEMENT SYSTEM


# Product Description / Presentation #

INTELLIGENT SMART CITY MANAGEMENT SYSTEM


Build Brief • Claude-Optimized • Production-Ready

Product description / presentation
CivitasIQ is a unified, AI-driven command platform for modern cities. It fuses live sensor data, geospatial feeds, and citizen inputs into a real-time city twin that forecasts demand, flags anomalies, and coordinates response across mobility, energy, water, waste, and public safety. Teams get an operational picture, automated alerts, what-if simulations, and agent-assisted actions.

Why people/teams love it:
• One pane of glass for all city operations (traffic, transit, utilities, incidents, permits).
• Real-time insights with explainable forecasts and policy-grounded recommendations.
• Digital-twin interactions: simulate road closures, reroute transit, re-time signals, adjust energy loads.
• Agentic co-pilots: research policy constraints, summarize incidents, draft stakeholder updates, generate SOP checklists.
• Built for trust: audit trails, RBAC, data lineage, and human-in-the-loop approvals.
Framework choice & why
• Orchestration: LangGraph on top of LangChain — deterministic, stateful multi-agent flows (ingestion → quality → forecast → recommend → approve → act) with checkpointing and human approval gates.
• Retrieval: RAG over municipal policies, contracts, SOPs, vendor manuals using pgvector; provenance and timestamps enforced.
• GenAI: OpenAI + Anthropic for summarization, reasoning, multilingual comms; structured JSON outputs for safe automation.
• Core stack (fixed by spec): Next.js 14 (App Router), FastAPI (async), PostgreSQL (+PostGIS, TimescaleDB, pgvector), Redis (cache/queues), Vercel + Render.
1. BACKEND ARCHITECTURE (extensive)
• FastAPI (async) service layout: /apps/{domain} (mobility, utilities, safety, permits), /core (auth, users, tenants, RBAC), /ai (agents, RAG, models).
• Domain micro-modules with routers: mobility.traffic, mobility.transit, utilities.energy, utilities.water, safety.incidents, citizen.feedback.
• API styles: REST for CRUD/config; WebSockets for live channels (/ws/alerts, /ws/telemetry, /ws/command); background jobs for heavy compute.
• Data ingestion adapters:
•   • MQTT/HTTP for IoT gateways (air quality, parking, meters) with TLS + mTLS option.
•   • GTFS-Realtime (transit), traffic loop counters, signal controllers (NTCIP), bike/scooter APIs.
•   • CAD/911 incident feed (secured), weather APIs, utility SCADA via OPC-UA proxy (read-only).
•   • Camera edge inferencing hook (optional) via RTSP → edge gateway → event counts (no PII payloads).
• Event pipeline:
•   • Write-ahead raw_events table → streaming normalizer → feature enricher (geo, hour-of-day, weather join) → facts tables.
•   • Optional Kafka/Redpanda for high-throughput fan-out; Redis Streams as lightweight alternative.
• PostgreSQL extensions: PostGIS (geospatial), TimescaleDB (time-series), pgvector (RAG & similarity).
• Schema highlights:
•   • core.users, core.tenants, core.roles, core.audit_logs
•   • geo.assets(id, type, geom, meta), geo.zones(id, name, polygon, rules)
•   • ts.telemetry(asset_id, ts, metrics jsonb, tags jsonb, location geography(Point)) (hypertable)
•   • ops.incidents(id, source, status, severity, geom, started_at, resolved_at, links jsonb)
•   • ops.recommendations(id, incident_id?, type, payload jsonb, rationale, confidence, created_at)
•   • rag.documents(id, tenant_id, source_uri, title, text, metadata jsonb, embedding vector)
•   • mobility.signals(id, controller_ref, phase_plan jsonb), mobility.travel_times(corridor_id, ts, minutes)
• Caching & queues: Redis (keys: session:*, cache:*, queue:*). Prefer Redis RQ/Arq workers for: model inference batches, ETL, exports.
• AI services (FastAPI subapp /ai):
•   • RAG pipeline: loader → chunker (policy-aware) → embed → store (pgvector) → cite & quote spans in responses.
•   • Forecasting service: demand (transit ridership), traffic volume, energy load, water usage (Prophet/Neural forecasting behind API).
•   • Optimization: signal timing suggestion, plow/collection routing (heuristics + constraints) output as JSON ops.
•   • Agents via LangGraph: Data Quality Agent, Policy Compliance Agent, Incident Summarizer, Recommender, Notifier.
• Digital Twin service: entity graph of assets/links/states with scenario sandbox (what-if write set kept separate).
• Security & auth: JWT (access/refresh), tenant scoping, RBAC (role→permission matrix), IP allowlists for admin APIs.
• Auditing & lineage: all AI outputs stored with inputs, prompt hash, model, embeddings, source doc IDs, and user approver.
• File/Blob storage: S3-compatible (minio/AWS) for documents, exports, tiles; signed URLs via backend.
• Geospatial utilities: isochrones, snapping, geofencing enter/exit triggers; map tile generation job (mbtiles).
• Rate limiting & quotas: per-tenant, per-route; burst + sustained with sliding window in Redis.
• Internationalization: backend locale middleware; time zone normalization (UTC storage, client zone render).
• Deployment profiles: dev (sqlite for local), staging/prod (Postgres), migrations via Alembic with PostGIS/Timescale enable scripts.
2. FRONTEND ARCHITECTURE
• Next.js 14 App Router with feature folders: /(dashboard)/(mobility)/(utilities)/(safety)/admin.
• State/data: React Query (server state), Zustand (local UI), URL-as-state for filters; optimistic UI for config changes.
• Real-time: WebSocket hook useLiveChannel(topic) with backoff + presence; toasts for alerts; activity ticker.
• Geospatial UI: Mapbox GL JS layer manager (heatmaps, choropleths, incidents, isochrones), deck.gl optional for large layers.
• Charts: Recharts/Victory for time-series; virtualized tables for telemetry and incidents.
• Workflows: incident triage drawer, recommendation review modal (explanations, citations), one-click actions with approval.
• Scenario Studio: side-by-side compare (baseline vs proposed), sandbox commit with diff summary.
• Admin: user/role manager, data source configs, API keys, quotas, webhook destinations.
• Design system: Tailwind + shadcn/ui components; tokens for light/dark + high-contrast; LTR/RTL support.
• Accessibility: keyboard-first navigation, screen-reader labels, live region updates for alerts.
• Internationalization: next-intl; numeral/date localization; unit toggles (imperial/metric).
• File flows: drag-drop for policy PDFs/CSVs/GeoJSON with progress; inline validation and data dictionaries.
• Offline/Resilience: SW caching of static assets; request replay for minor outages (non-critical ops).
3. DESIGN REQUIREMENTS (UI/UX)
• Operational clarity: status-first layouts, color-safe severities, dense tables with row focus mode.
• Geospatial-first: map as primary canvas with dockable panels; responsive to kiosk, tablet, desktop.
• Progressive disclosure: overview → drilldown → action; breadcrumbs & timeline scrubber for incidents.
• Micro-interactions: hover states reveal KPIs and trend sparklines; skeleton loaders for streaming tiles.
• Accessibility: WCAG 2.1 AA (contrast ≥ 4.5:1, focus rings, captions on videos, live region announcements).
• Branding: city theming (logo, colors) via CSS variables; emergency mode theme with high-contrast palette.
4. CORE INTEGRATIONS
• OpenAI & Anthropic (LLM): summarization, recommendations, multilingual communications; JSON-mode outputs.
• Map & Geo: Mapbox, PostGIS, GeoJSON import/export; optional ESRI Feature Service connector.
• Transit & Mobility: GTFS/GTFS-RT, signal controllers (NTCIP), connected vehicle feeds (read-only).
• Utilities: OPC-UA proxy (read), smart meter batch imports (CSV/Parquet), energy market pricing APIs (read).
• Messaging: Redis Streams (baseline) or Kafka/Redpanda (high-throughput).
• Storage: S3-compatible object store for docs/tiles/exports.
• Auth: SSO via SAML/OIDC (Azure AD, Okta).
• Notifications: SMTP/SendGrid; webhooks (Teams/Slack) with templated payloads.
5. DELIVERABLES REQUIRED
• Next.js 14 frontend with TypeScript/Tailwind, role-based dashboards, map & charts, real-time alerts UI.
• FastAPI backend (async) with domain routers, WebSockets, workers, and documented OpenAPI.
• PostgreSQL schema with PostGIS, TimescaleDB hypertables, and pgvector stores; Alembic migrations.
• RAG pipeline over policy/SOP documents with citation UI and evidence storage.
• Forecasting & optimization services with APIs and scenario endpoints.
• File ingestion pipelines (CSV/GeoJSON/PDF) with validation and lineage.
• Email/webhook notification system with templates and throttling.
• IaC-ready deployment configs for Vercel (FE) and Render (BE); env var matrix.
• Comprehensive docs (runbooks, API, data dictionary) and onboarding sample dataset.
6. SUCCESS CRITERIA
• Unified operational picture updates in near real-time (<5s p95 from ingest to UI for standard topics).
• Explainable recommendations with linked citations and confidence scoring for all AI outputs.
• City-scale geospatial layers render at 60fps on modern desktops, 30fps on tablets (typical datasets).
• No critical actions applied without human approval; all automations are reversible with audit logs.
• Multi-tenant isolation verified; RBAC enforced on every route and WebSocket topic.
7. IMPLEMENTATION GUIDELINES
• Type safety end-to-end: Pydantic v2 schemas ↔ TypeScript types (openapi-typescript generation).
• Consistent IDs/keys: UUIDv7 for entities; ULIDs acceptable for telemetry partitions.
• Idempotency: POST actions include idempotency keys; exporters deduplicate by content hash.
• Prompts as code: store system & task prompts in repo with versions; include tests and linting.
• RAG hygiene: chunk by structure (headings/tables), store source offsets; block responses without sources for policy Q&A.
• Geospatial best practices: store geometry in SRID 4326; index with GIST; avoid large payloads to client (tiling/gzip).
• Background work: offload heavy compute to workers; use backpressure signals on ingestion.
• WebSocket etiquette: small deltas, heartbeat/ping, resumable cursor for streams.
• Docs-first APIs: keep OpenAPI in sync; include examples and error models; paginate consistently.
8. SECURITY & COMPLIANCE
• Data classification: public / internal / restricted; PII minimization; no biometric/face payloads stored.
• Encryption: TLS 1.2+ in transit; AES-256 at rest (DB & object storage); KMS-managed keys; envelope encryption for secrets.
• RBAC & tenancy: per-tenant schemas or row-level security; JWT with short TTL; refresh + rotation; device/session revocation.
• Audit & lineage: append-only logs for admin & AI actions; prompt/response archival with hashes and source IDs.
• Model safety: content filters; jailbreak protection; output moderation; explicit disclaimers for non-binding recommendations.
• Compliance alignment: ISO 27001/SOC 2 controls; GDPR/CCPA data rights; CJIS-compatible mode for public safety tenants.
• Supply chain: pin images; verify checksums; SBOM generation; dependency scanning; signed container images.
• Incident response: playbooks, on-call runbooks, webhooks to paging tools; forensics-ready log retention.
Claude — 5 critical prompts (builds on prebuilt repo)
PROMPT 1 — PROJECT SETUP & ARCHITECTURE (use existing scaffold)
Assume the monorepo is already initialized with Next.js 14 (App Router), FastAPI (async), Postgres (+PostGIS, TimescaleDB, pgvector), Redis, and LangGraph/LangChain. Do NOT change the stack. Generate only new/modified files as unified patches. Add Alembic migrations to enable PostGIS, TimescaleDB, and vector indexes; create schemas core, geo, ts, ops, rag. Output: file tree + patches + env.sample updates.
PROMPT 2 — CORE BACKEND IMPLEMENTATION (routers, models, ws, workers)
Within /backend, implement domain routers (mobility, utilities, safety), Pydantic schemas, and CRUD. Add WebSocket topics /ws/alerts and /ws/telemetry with heartbeat and replay cursors. Implement Redis RQ/Arq workers for ETL, forecasting, and exports. Create RAG service endpoints (/ai/ask, /ai/search) with citation returns. Output: code diffs, OpenAPI excerpt, and curl examples.
PROMPT 3 — FRONTEND COMPONENTS & UI (dashboards, map, real-time)
Within /frontend, implement dashboards and a Mapbox layer manager. Create hooks useLiveChannel and useScenarioSandbox. Build IncidentTriageDrawer and RecommendationReviewModal with citation side panel. Ensure a11y attributes and keyboard flows. Output: file diffs, route map, and demo seed data JSON.
PROMPT 4 — AI INTEGRATION & FEATURES (LangGraph agents, RAG, forecasts)
Implement LangGraph agents: DataQualityAgent, PolicyComplianceAgent, IncidentSummarizer, Recommender. Wire RAG over /rag.documents with quote spans and confidence. Wrap forecasting (traffic/energy/water) behind /ai/forecast endpoints. All outputs must be structured JSON with rationale and confidence. Provide prompt templates as code.
PROMPT 5 — DEPLOYMENT & OPTIMIZATION (configs, seeds, idempotency)
Provide Vercel (FE) and Render (BE) configs, Dockerfiles, and Procfiles. Add seed scripts for demo city data, role templates, and sample documents. Implement idempotency keys, rate limiting, and signed URLs. Output: deployment steps and .env matrices.




FOLLOW THIS 8 STEP PLAN TO PREPARE THE INFRASTRUCTURE
-----------------------------------------------------

# 🚀 Claude Fullstack Repo Prep – Optimized 8 Step Plan

  
The goal: build an extensive frontend + backend scaffold so Claude Code only has to finish ~20% of the work.  
Each step must be **completed and reviewed** before advancing.
IMPORTANT: YOU ARE BUILDING ONLY THE INFRASTRUCTURE OF THE APPLICATION NOT THE APPLICATION ITSELF !!!. FOLLOW THE STEPS IN NUMERICAL ORDER !!! starting from step 1.
You are doing the groundwork for the application, including setting up the folder structure, configuration files, and any necessary boilerplate code.
IMPORTANT: the checklist in each step has to be checked off 100% before moving to the next step

---

## STEP 1 — Build the Rich Infrastructure
Create a **deep scaffold** for both frontend and backend so Claude code can recognize the architecture immediately.

- Build a **frontend app shell** with routing, placeholder pages, components, and styling setup.  
- Build a **backend app shell** with API structure, health endpoint, and config in place.  
- Include `REPO_MAP.md`, `API_SPEC.md`, and a draft `CLAUDE.md` in the `docs/` folder.  (create the docs folder if it does not exist)
- Add **TODO markers and folder-level `_INSTRUCTIONS.md`** files so Claude knows exactly where to add logic.

**Deliverables**
- Frontend app shell with routing, placeholder pages, components, and styling setup  
- Backend app shell with API structure, health endpoint, and config  
- `docs/REPO_MAP.md`, `docs/API_SPEC.md` (stub), and draft `docs/CLAUDE.md`  
- TODO markers + folder-level `_INSTRUCTIONS.md` files  

**Checklist**
- [ ] Frontend scaffold built  
- [ ] Backend scaffold built 
- [ ] Docs folder created with drafts (`REPO_MAP.md`, `API_SPEC.md`, `CLAUDE.md`)  
- [ ] TODO markers and `_INSTRUCTIONS.md` stubs in place  

---

## STEP 2 — Enrich the Scaffold
If the repo looks shallow, enrich it so Claude needs fewer leaps of imagination.  

Add:
- Sample frontend routes and components (`/`, `/about`, `/dashboard`)  
- Domain model stubs and types/interfaces  
- Mock data + fixtures for UI flows  
- README files with quick run instructions for both frontend and backend  
- Instructions embedded in folders (e.g. `CLAUDE_TASK: …`)

**Deliverables**
- Sample routes and pages (`/`, `/about`, `/dashboard`)  
- Domain model stubs and type definitions  
- Mock data and fixtures for UI flows  
- README files for frontend and backend with run instructions  
- Folder-level instructions (`_INSTRUCTIONS.md`)  

**Checklist**
- [ ] At least 2–3 sample routes/pages exist  
- [ ] Domain types/interfaces stubbed out  
- [ ] Mock data + fixtures included  
- [ ] README_FRONTEND.md and README_BACKEND.md added  
- [ ] Each folder has `_INSTRUCTIONS.md` where relevant 

---

## STEP 3 — Audit for Alignment
Check that the scaffold actually matches the product brief, tech specs, and UX goals.
Add additional UI/UX elements (if needed) to make the application visually appealing (and update the design requirements after that)

- Do navigation and pages reflect the product’s main flows?  
- Do API endpoints match the UI needs?  
- Is the chosen tech stack consistent (no unused or conflicting libraries)?  
- Is the UX direction reflected (design tokens, layout, component stubs)?

**Deliverables**
- Alignment review across Product ↔ UI/UX ↔ Tech  
- Identify any missing flows, mismatched libraries, or conflicting instructions  

**Checklist**
- [ ] Navigation structure matches product journeys  
- [ ] Components/pages map to required features  
- [ ] API endpoints cover MVP needs  
- [ ] No contradictory or unused technologies  

---

## STEP 4 — Document the Architecture
Now make the docs **Claude-ready**:

- **REPO_MAP.md**: Full repo breakdown with roles of each folder  
- **API_SPEC.md**: Endpoints, payloads, error handling  
- **CLAUDE.md**: Editing rules, coding conventions, AI collaboration guidelines  

These three files are the **context backbone** Claude will use to understand the repo.

**Deliverables**
- `REPO_MAP.md`: full repo breakdown with folder purposes  
- `API_SPEC.md`: endpoints, models, error conventions  
- `CLAUDE.md`: collaboration rules, editing boundaries  

**Checklist**
- [ ] REPO_MAP.md fully describes structure  
- [ ] API_SPEC.md covers all MVP endpoints and schemas  
- [ ] CLAUDE.md includes project overview, editing rules, examples  

---

## STEP 5 — Improve the Prompt
Enhance the prompt (in `docs/PROMPT_DECLARATION.md`) with details Claude needs:

- FE/BE boundaries and data contracts  
- UX guidelines (states, accessibility, interaction patterns)  
- Performance budgets (bundle size, API latency)  
- Security constraints (auth, rate limits, PII handling)  
- Testing expectations (unit, integration, end-to-end)

**Deliverables**
- FE/BE boundaries and contracts  
- UX guidelines (states, accessibility, patterns)  
- Performance budgets (bundle size, latency targets)  
- Security constraints (auth, PII, rate limits)  
- Testing expectations  

**Checklist**
- [ ] Prompt includes FE/BE division of responsibility  
- [ ] UX principles and design tokens specified  
- [ ] Performance/security/testing requirements added  
- [ ] Prompt is concrete and actionable for Claude  

---

## STEP 6 — Expert Audit of the Prompt
Now do a **meticulous audit** of the one-page prompt declaration.

- Add Frontend Architecture, Backend Architecture, Design requirements, Core Integrations, Success Criteria, Implementation Guidelines and Security & Compliance categories from this Project Brief to the prompt declaration.
- Remove inconsistencies, duplicates, or unused technologies  
- Ensure Tech Stack → Product → Scaffold alignment (no mismatches)  
- Add UI/UX details that make the product visually appealing and usable  
- Double-check frontend and backend folders are ready  
- Confirm editing boundaries are clear (what Claude can/can’t touch)  
- Make the declaration **battle-tested and handoff-ready**

**Deliverables**
- Remove inconsistencies/duplicates  
- Ensure stack ↔ product ↔ scaffold alignment  
- Add UI/UX and accessibility details  
- Clarify file boundaries (editable vs do-not-touch)  
- Confirm prompt uses Claude-friendly syntax  

**Checklist**
- [ ] No unused or contradictory tech remains  
- [ ] UI/UX directives are product-specific and sufficient  
- [ ] Editing boundaries explicitly defined  
- [ ] Prompt syntax uses clear, imperative instructions  

---

## STEP 7 — Bird’s-Eye Repo Review
Do a quick top-level scan for missing pieces:

- All folders contain either code or `_INSTRUCTIONS.md`  
- `.env.example` files exist for both frontend and backend  
- CI/CD config is present and not trivially broken  
- Run scripts (`npm run dev`, `uvicorn …`) work end-to-end  
- No orphan TODOs without clear ownership

**Deliverables**
- Verify all core files exist  
- Confirm environment, CI, and scripts work end-to-end  

**Checklist**
- [ ] Every folder has code or `_INSTRUCTIONS.md`  
- [ ] `.env.example` present for both frontend and backend  
- [ ] CI pipeline triggers and passes basic checks  
- [ ] Dev script (`scripts/dev.sh`) runs both FE and BE  

---

## STEP 8 — Finalize CLAUDE.md
This is where Claude gets its **onboarding pack**. Make sure `CLAUDE.md` includes:

- **Project Overview**: one-paragraph purpose, stack, goals, target users  
- **Folder & File Structure**: what’s editable vs do-not-touch  
- **Coding Conventions**: style guides, naming rules, commenting expectations  
- **AI Collaboration Rules**: response format, edit rules, ambiguity handling  
- **Editing Rules**: full-file vs patches, locked files  
- **Dependencies & Setup**: frameworks, services, env vars  
- **Workflow & Tools**: how to run locally, FE/BE boundary, deployment notes  
- **Contextual Knowledge**: product quirks, domain rules, business logic caveats  
- **Examples**: good vs bad AI answer

**Deliverables**
- Project overview (purpose, stack, goals, users)  
- Folder & file structure with editable vs do-not-touch  
- Coding conventions (style, naming, commenting)  
- AI collaboration rules (response style, edit rules, ambiguity handling)  
- Dependencies and setup instructions  
- Workflow, deployment notes, contextual knowledge  
- Good vs bad answer examples  
- Fill out all the missing information in the CLAUDE.md file

**Checklist**
- [ ] Project overview section filled in  
- [ ] File boundaries clearly defined  
- [ ] Coding/style conventions included  
- [ ] AI collaboration & editing rules written  
- [ ] Dependencies & env notes covered  
- [ ] Workflow & deployment info added  
- [ ] Contextual knowledge documented  
- [ ] Good vs bad examples included  
- [ ] CLAUDE.md file does not miss any important information

---

# ✅ Outcome
When this 8-step plan is followed:
- The repo is a **rich, opinionated scaffold** (80% done).  
- Docs give Claude **clear boundaries + context**.  
- The one-page prompt is **battle-tested** and aligned.  
- Claude Code can safely and efficiently generate the missing 20%.  












